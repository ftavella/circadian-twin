[
  {
    "objectID": "examples/effect_of_pulses.html",
    "href": "examples/effect_of_pulses.html",
    "title": "Circadian rhythm disruptions",
    "section": "",
    "text": "Light exposure is one of the main factors affecting circadian rhythms. Here we use the circadian package to explore the effects of light pulses at different times of the day. We will explore this effect using four different circadian models Forger99, Jewett99, Hannay19, and Hannay19TP and compare the results among them.\n\nEntraining models to a regular light schedule\nFirst, we entrain each model to a regular light schedule to have a baseline to compare to. In circadian we do this by\n\ndt = 0.1 # hours\ndays = 20\ntime = np.arange(0, 24 * days, dt)\nregular_lux = 500\nschedule = LightSchedule.Regular(regular_lux, lights_on=8, lights_off=24)\nlight_input = schedule(time)\nmodel_list = [Forger99(), Jewett99(), Hannay19(), Hannay19TP()]\nequilibrium_states = []\n\nfor model in model_list:\n    time_eq = np.arange(0, 24 * days, dt)\n    final_state = model.equilibrate(time_eq, light_input, num_loops=2)\n    equilibrium_states.append(final_state)\n\n\n\nPulse during the day\nNext, we can explore how models respond to lights pulse during the bright hours of the day. We can use the LightSchedule.from_pulse function to add pulses at different times\n\ndays = 3\ntime = np.arange(0, 24 * days, dt)\npulse_num = 6\npulse_lux = 1e4\npulse_duration = 1 # hour\nstart_values = np.linspace(32, 47, pulse_num)\n\nsimulation_result = {}\n\nfor idx,model in enumerate(model_list):\n    simulation_result[str(model)] = {}\n    for pulse_start in start_values:\n        schedule = LightSchedule.Regular(regular_lux, lights_on=8, lights_off=24)\n        schedule += LightSchedule.from_pulse(pulse_lux, pulse_start, pulse_duration)\n        light_input = schedule(time)\n        trajectory = model(time, equilibrium_states[idx], light_input)\n        simulation_result[str(model)][str(pulse_start)] = {\n            'light': light_input,\n            'trajectory': trajectory\n        }\n\n\nForger99Jewett99Hannay19Hannay19TP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe see that light pulses during bright hours don’t have a major effect on circadian rhythms. However, this is not the case for light pulses during darkness.\n\n\nPulse at night\nUsing the same code as above but with different pulse start values\n\nstart_values = np.linspace(24, 31, pulse_num)\n\ngives us the following\n\nForger99Jewett99Hannay19Hannay19TP\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModels are more sensitive to pulses during the dark hours of the day, the sinusoidal signal changes abruptly when the pulse is applied. This reflects an important property of circadian rhythms: their sensitivity to light is dependent on the current phase of the clock. We can calculate how much the phase of the clock changes after a pulse by constructing a phase response curve (PRC).\n\n\nBuilding phase response curves\nTo build a phase response curve we need to calculate how much the phase of the clock changed after the pulse ended with respect to an unperturbed clock. We can do this the following way\n\nfrom circadian.utils import phase_difference\n\n\nmodel = Forger99()\n\ndays = 3\ntime = np.arange(0, 24 * days, dt)\npulse_lux = 1e4\npulse_start = 25 # hours\npulse_duration = 1 # hour\n\nregular_schedule = LightSchedule.Regular(regular_lux, lights_on=8, lights_off=24)\npulse = LightSchedule.from_pulse(pulse_lux, pulse_start, pulse_duration)\npulse_schedule = regular_schedule + pulse\n\nregular_light = regular_schedule(time)\npulse_light = pulse_schedule(time)\n\nregular_trajectory = model(time, equilibrium_states[0], regular_light)\npulse_trajectory = model(time, equilibrium_states[0], pulse_light)\n\npulse_end = pulse_start + pulse_duration\n\nregular_phase = model.phase(regular_trajectory, pulse_end)\npulse_phase = model.phase(pulse_trajectory, pulse_end)\n\nphase_diff = phase_difference(regular_phase, pulse_phase)\n\nPhase difference: -0.16 radians\n\n\nThis negative value means that the pulse delays the clock. We can visualize this by comparing the state of the clock before and after the pulse\n\n\n\n\n\nHere we can also observe that the amplitude of the clock is reduced after the pulse. To calculate this we do the following\n\nfrom circadian.utils import amplitude_percent_change\n\n\nregular_amplitude = model.amplitude(regular_trajectory, pulse_end)\npulse_amplitude = model.amplitude(pulse_trajectory, pulse_end)\n\namplitude_change = amplitude_percent_change(regular_amplitude, pulse_amplitude)\n\nAmplitude change: -12.40%\n\n\nSo the pulse both delays the clock and reduces its amplitude. We can now calculate the phase response curve by repeating this process for different pulse times. We will also store the amplitude change information for the following section.\n\ndays = 2.5\ndt = 0.02 # hours. We need a smaller dt to get a smooth phase response curve\ntime = np.arange(0, 24 * days, dt)\npulse_num = 150\npulse_lux = 1e4\npulse_duration = 1 # hour\nstart_values = np.linspace(24, 48, pulse_num)\n\n\nfor idx,model in enumerate(model_list):\n    simulation_result[str(model)] = {\n        'cbtmin': np.NaN,\n        'phase_response': [],\n        'amplitude_response': [],\n    }\n    # create the reference trajectory\n    regular_schedule = LightSchedule.Regular(regular_lux, lights_on=8, lights_off=24)\n    regular_light = regular_schedule(time)\n    regular_trajectory = model(time, equilibrium_states[idx], regular_light)\n\n    # calculate cbt to use as pulse start time reference\n    cbtmin = model.cbt(regular_trajectory)[1]\n    simulation_result[str(model)]['cbtmin'] = cbtmin\n\n    for pulse_start in start_values:\n        schedule = LightSchedule.Regular(regular_lux, lights_on=8, lights_off=24)\n        schedule += LightSchedule.from_pulse(pulse_lux, pulse_start, pulse_duration)\n        light_input = schedule(time)\n        pulse_trajectory = model(time, equilibrium_states[idx], light_input)\n\n        pulse_end = pulse_start + pulse_duration\n\n        regular_phase = model.phase(regular_trajectory, pulse_end)\n        pulse_phase = model.phase(pulse_trajectory, pulse_end)\n        phase_diff = phase_difference(regular_phase, pulse_phase)\n        simulation_result[str(model)]['phase_response'].append(phase_diff)\n\n        regular_amplitude = model.amplitude(regular_trajectory, pulse_end)\n        pulse_amplitude = model.amplitude(pulse_trajectory, pulse_end)\n        amplitude_change = amplitude_percent_change(regular_amplitude, pulse_amplitude)\n        simulation_result[str(model)]['amplitude_response'].append(amplitude_change)\n\n# convert phase differences from radians to hours\nperiod = 24.2 # hours\nfor model in model_list:\n    phase_response = simulation_result[str(model)]['phase_response']\n    phase_response = np.array(phase_response) * period / (2 * np.pi)\n    simulation_result[str(model)]['phase_response'] = phase_response\n\n\n\n\n\n\nThis is the phase response curve for four different models. On the y-axis we have how much the phase of the circadian clock changes when the pulse ends. Positive values mean the clock is advanced with respect to an unperturbed case. On the x-axis we have the pulse end time relative to the core body temperature minimum (CBTmin). When the pulse ends close to CBTmin (x-axis value of 0) the phase of the clock is maximally advanced. On the contrary, when the pulse ends five hours before CBTmin, the clock is delayed the most. The overall shape of the response is similar between models.\n\n\nBuilding amplitude response curves\nOur previous simulation shows that not only the phase of the clock changes after a pulse, but also its amplitude. We already calculated the amplitude change in the previous section so we can plot the result\n\n\n\n\n\nThe models still have a similar response: all of them show a decrease in amplitude four hours before CBTmin. However, the magnitude of change in amplitude varies between them. For a more detailed discussion we refer the reader to Hannay et al. (2019)."
  },
  {
    "objectID": "contributing.html",
    "href": "contributing.html",
    "title": "Contributing to circadian",
    "section": "",
    "text": "Thanks for contributing to circadian! We welcome issues, pull requests, and comments on GitHub. Please read the following guidelines for more details on how to contribute."
  },
  {
    "objectID": "contributing.html#example",
    "href": "contributing.html#example",
    "title": "Contributing to circadian",
    "section": "Example",
    "text": "Example\nLet’s assume we want to add a new feature to circadian for calculating the average sleep duration of a person given a set of timepoints and sleep states. This new feature will add a new function called average_sleep_duration to the utils module of circadian. First, we need to create a new branch for this feature. We can do this by running the following command in the terminal:\ngit checkout -b avg-sleep-duration\nThen, we open the notebook corresponding to the utils module which is located at circadian/nbs/api/07_utils.ipynb. We can see that the notebook contains many cells at the top where we import python packages, then a couple of function definitions, and finally a cell where we tell nbdev to export the code in this notebook to .py files. We will add our code just before this final cell.\nWe create a new cell and add the following code to it:\n#| export\n#| hide\ndef average_sleep_duration(time: np.ndarray, # time array in hours\n                           sleep: np.ndarray # sleep/wake information. 1 for sleep, 0 for wake\n                           ) -&gt; float: # average sleep duration in hours\n    \"Calculate the average sleep duration from a sleep/wake array.\"\n    # input validation\n    if not isinstance(time, np.ndarray):\n        raise TypeError(\"time must be a numpy array\")\n    if not isinstance(sleep, np.ndarray):\n        raise TypeError(\"sleep must be a numpy array\")\n    if time.shape != sleep.shape:\n        raise ValueError(\"time and sleep must have the same shape\")\n    # calculate sleep duration\n    sleep_starts = np.where(np.diff(sleep) == 1)[0]\n    sleep_ends = np.where(np.diff(sleep) == -1)[0]\n    sleep_durations = time[sleep_ends] - time[sleep_starts]\n    return np.mean(sleep_durations)\nSeveral things to notice:\n\nAt the top of our cell we are including nbdev directives. These are special comments that tell nbdev how to process the cell. In this case, we are telling nbdev to export (#| export) the cell to the .py source file and not to show (#| hide) the cell or its output in the documentation.\nWe are using type-hinting to specify the type of the input and output of our function. This is not required, but it is good practice and will help us catch errors.\nAfter each function input and output we’re adding a comment explaining what the input/output is. This is important to generate good documentation. nbdev will automatically convert these comments into documentation for us when we build our documentation site. Similarly, the string after the function definition will be used as the function’s docstring.\n\nBelow this line we can add some text describing what our function does and an example outlining how to use it. We do this by creating the following three cells:\n# Average sleep duration\nThis function calculates the average sleep duration for a dataset of sleep logs. For example,\ntime = np.linspace(0.0, 108.0, 100)\nsleep = np.sin(2 * np.pi * time / 24.0)\nsleep[sleep &gt;= 0] = 0.0\nsleep[sleep &lt; 0] = 1.0\naverage_sleep = average_sleep_duration(time, sleep)\nprint(average_sleep) #| hide_line\n#| echo: false\nplt.plot(time / 24.0, sleep)\nplt.axhline(y=averag_sleep, color='r', linestyle='--',\n            label='Average sleep duration')\nplt.xlabel('Time (days)')\nplt.ylabel('Sleep state')\nplt.show()\nIn this case:\n\nThe first cell (in Markdown) will appear rendered as text in the documentation website\nThe second cell will appear rendered as a code cell in the documentation website without the print statement (#| hide_line). However, below the cell we will see the output of print.\nThe third cell will only show the final plot (#| echo: false). The code will not appear in the documentation but it’s output will.\n\nFinally, we want to test that our function works properly. To do this we head to circadian/nbs/test/test_utils.ipynb (or create it if it doesn’t exist) and add the following cells:\n#| hide \n%load_ext autoreload\n%autoreload 2\nimport numpy as np\nfrom fastcore.test import * # if not already present\nfrom circadian.utils import average_sleep_duration\n# test average_sleep_duration\ntime = np.linspace(0.0, 108.0, 100)\nsleep = np.sin(2 * np.pi * time / 24.0)\nsleep[sleep &gt;= 0] = 0.0\nsleep[sleep &lt; 0] = 1.0\naverage_sleep = average_sleep_duration(time, sleep)\ntest_eq(np.isclose(average_sleep, 12.0), True)\n# test input validation\ntest_fail(lambda: average_sleep_duration([1.0, 1.0], sleep), \n          contains=\"time must be a numpy array\")\ntest_fail(lambda: average_sleep_duration(time, [1.0, 1.0]),\n            contains=\"sleep must be a numpy array\")\ntest_fail(lambda: average_sleep_duration(time, sleep[:-1]), \n          contains=\"time and sleep must have the same shape\")\n\nThe first cell tells IPython to reload imported modules before execution. It’s useful for development. See more details at IPython’s documentation.\nnbdev requires import statements to be in different cells than code. So that’s why we have a separate imports cell.\nFor testing, we can use nbdev functions to test our code such as test_eq and test_fail. See more details at nbdev’s documentation.\n\nOnce we are done writing our code, tests, and documentation we’re ready to generate the source .py files and strip notebooks of innecessary information. This is done by running the following command from the root of the repository:\nnbdev_prepare\nIf the code in all notebooks is valid and no cell throws an error you should see a Success output.\nThen we can follow the usual git workflow to get our changes into our fork:\ngit add .\ngit commit -m \"Add Average sleep calculation, tests, and docs\"\ngit push --set-upstream origin avg-sleep-duration # This will create a new branch on our fork\nFinally, we can open a pull request on GitHub to get our changes into the main repository. Arcascope developers will review your pull request and merge it into the main repository if everything looks good! Here’s more info on creating a pull request.\nTherefore, the steps to add a new feature to circadian using nbdev are:\n\nGo to the notebook you want to modify or create a new one in the nbs folder\nAdd your code with the proper directives and documentation\nAdd your tests on circadian/nbs/test/TEST_FILE.ipynb\nSave notebooks and run nbdev_prepare from the root folder\nCommit and push your changes to GitHub\nCreate a pull request to the main branch\nWait for our review!"
  },
  {
    "objectID": "api/cli.html",
    "href": "api/cli.html",
    "title": "CLI",
    "section": "",
    "text": "!acto --help\n\nusage: acto [-h] [-j JSON] [-c CSV] [-sm SLEEPMODEL] [-d] [-cbt] [--sleep]\n            [-t THRESHOLD] [-m MULTIPLIER] [-p PERIOD] [-r] [--scatter]\n            [-t1 T1] [-t2 T2] [-s SIGMA]\n\nMake an actogram\n\noptions:\n  -h, --help            show this help message and exit\n  -j JSON, --json JSON  Specify a json file with the data\n  -c CSV, --csv CSV     Specify a directory with csv data in it\n  -sm SLEEPMODEL, --sleepmodel SLEEPMODEL\n                        Machine learning pytorch model for steps and heartrate\n                        to wake prediction\n  -d, --dlmo            Integrate the model and plot dlmo times\n  -cbt, --cbt           Integrate the model and plot core body temperature\n                        times\n  --sleep               Add sleep midpoints\n  -t THRESHOLD, --threshold THRESHOLD\n                        Threshold for displaying as light on the actogram\n  -m MULTIPLIER, --multiplier MULTIPLIER\n                        Steps to light multiplier\n  -p PERIOD, --period PERIOD\n                        Set the SPM period\n  -r, --raw             Plot the raw steps and heartrate data\n  --scatter             Plot the raw steps and heartrate data\n  -t1 T1, --t1 T1       Trim data before this time, in days\n  -t2 T2, --t2 T2       Trim data after this time, in days\n  -s SIGMA, --sigma SIGMA\n                        Smooth the light(steps) data\n\n\n\n!esri --help\n\nusage: esri [-h] [-a] [-j JSON] [-c CSV] [-s SIGMA] [-t1 T1] [-t2 T2]\n            [-sm SLEEPMODEL] [-t THRESHOLD] [-o OUTFILE] [-np]\n\nCompute the Entrainment Signal Regularity Index for a data set\n\noptions:\n  -h, --help            show this help message and exit\n  -a, --actogram\n  -j JSON, --json JSON  Specify a json file with the data\n  -c CSV, --csv CSV     Specify a directory with csv data in it\n  -s SIGMA, --sigma SIGMA\n                        Smooth the light(steps) data\n  -t1 T1, --t1 T1       Trim data before this time, in days\n  -t2 T2, --t2 T2       Trim data after this time, in days\n  -sm SLEEPMODEL, --sleepmodel SLEEPMODEL\n                        Machine learning pytorch model for steps and heartrate\n                        to wake prediction\n  -t THRESHOLD, --threshold THRESHOLD\n                        Threshold for displaying as light on the actogram\n  -o OUTFILE, --outfile OUTFILE\n                        Path to the outfile\n  -np, --noplot         Use this to suppress the plot"
  },
  {
    "objectID": "api/sleep.html",
    "href": "api/sleep.html",
    "title": "Sleep",
    "section": "",
    "text": "The below model uses a simple two process model for sleep to take a circadian trajectory and create a prediction of the homeostat (sleep hunger) which increases during wake and decreases during sleep. The steps parameter can be used to force wake, values of that array that are above the threshold will force a wake state.\n\nmodel = Hannay19()\ntime = np.arange(0, 24*30, 0.10)\nlight = LightSchedule.SlamShift()\nlight_est = light(time) \ntrajectory = model(time, input=light_est)\nsleep_model = TwoProcessModel()\nhomeostat = sleep_model(trajectory.time, trajectory.states[:,1], light_est)\n\n# Where the homeostat is increasing, we are awake where decreasing we are asleep\nwake_predicted = np.where(np.diff(homeostat.states[:,0],prepend=0.0) &gt; 0.0, 1.0, 0.0)\nax = plt.gca()\nActogram(time, light_vals=light_est, threshold=10.0, color='black', alpha=0.5, smooth=False, ax=ax)\nActogram(time, light_vals=wake_predicted, threshold=0.50, color='green', alpha=0.1, smooth=False, ax=ax);\nax.set_title('Sleep During a Slam Shift: Twp Process Model');"
  },
  {
    "objectID": "api/sleep.html#two-process-model",
    "href": "api/sleep.html#two-process-model",
    "title": "Sleep",
    "section": "",
    "text": "The below model uses a simple two process model for sleep to take a circadian trajectory and create a prediction of the homeostat (sleep hunger) which increases during wake and decreases during sleep. The steps parameter can be used to force wake, values of that array that are above the threshold will force a wake state.\n\nmodel = Hannay19()\ntime = np.arange(0, 24*30, 0.10)\nlight = LightSchedule.SlamShift()\nlight_est = light(time) \ntrajectory = model(time, input=light_est)\nsleep_model = TwoProcessModel()\nhomeostat = sleep_model(trajectory.time, trajectory.states[:,1], light_est)\n\n# Where the homeostat is increasing, we are awake where decreasing we are asleep\nwake_predicted = np.where(np.diff(homeostat.states[:,0],prepend=0.0) &gt; 0.0, 1.0, 0.0)\nax = plt.gca()\nActogram(time, light_vals=light_est, threshold=10.0, color='black', alpha=0.5, smooth=False, ax=ax)\nActogram(time, light_vals=wake_predicted, threshold=0.50, color='green', alpha=0.1, smooth=False, ax=ax);\nax.set_title('Sleep During a Slam Shift: Twp Process Model');"
  },
  {
    "objectID": "api/lights.html",
    "href": "api/lights.html",
    "title": "Lights",
    "section": "",
    "text": "The Lights module streamlines the process of creating light schedules for circadian models. Its main class is LightSchedule which facilitates creating light functions of time. LightSchedule objects can be added, subtracted, and concatenated between each other to create custom light schedules."
  },
  {
    "objectID": "api/lights.html#regular-light",
    "href": "api/lights.html#regular-light",
    "title": "Lights",
    "section": "Regular light",
    "text": "Regular light\nLightSchedule.Regular is a typical light schedule that repeats every 24 hours. The default schedule is 16 hours of light and 8 hours of darkness, but this can be changed by passing lights_on and lights_off to the constructor.\n\nregular_light = LightSchedule.Regular()\nax = regular_light.plot(0.0, 24*7.0)\nax.set_xlabel('Time (hours)');\nax.set_ylabel('Light (lux)');\nax.figure.set_size_inches(16, 4);\n# add a vertical line to the start of each day in dashed gray\nfor day in range(8):\n    ax.axvline(day*24.0, color='gray', linestyle='--');\nax.set_xticks(np.arange(0, 24.0*8.0, 12));\nax.set_xlim(0.0, 24.0*7.0);"
  },
  {
    "objectID": "api/lights.html#shift-worker",
    "href": "api/lights.html#shift-worker",
    "title": "Lights",
    "section": "Shift worker",
    "text": "Shift worker\nLightSchedule.ShiftWork approximates what a typical light schedule looks for some shift workers. The schedule is periodic over a whole work week (determined by the sum of days_on and days_off) and implements transitions between workdays and days off. The default schedule is:\n\nshift_schedule = LightSchedule.ShiftWork()\nax = shift_schedule.plot(0.0, 24.0*8.0)\nax.set_xlabel('Time (hours)');\nax.set_ylabel('Light (lux)');\nax.figure.set_size_inches(16, 4);\n# add a vertical line to the start of each day in dashed gray\nfor day in range(8):\n    ax.axvline(day*24.0, color='gray', linestyle='--');\nax.set_xticks(np.arange(0, 24.0*8.0, 12));\ndays_on = 5\ndays_off = 2\nlights_off_workday = 9.0\nlights_on_workday = 17.0\ntime_last_workday = lights_off_workday + 24*(days_on-1)\ntime_last_day_off = lights_on_workday + 24.0*(days_on + days_off - 1)\ntime_first_workday = time_last_day_off + lights_on_workday\n# set background color to light red for the workdays\nax.axvspan(0.0, time_last_workday, facecolor='r', alpha=0.1, label='Workdays');\nax.axvspan(time_last_day_off, time_first_workday, facecolor='r', alpha=0.1);\n# set background color to light green for days off\nax.axvspan(time_last_workday, time_last_day_off, facecolor='g', alpha=0.1, label='Days off');\n# set limits to be a week\nax.set_xlim(0.0, 24.0*7.0);\n# place legend at the top of the plot\nax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.15), ncol=2);"
  },
  {
    "objectID": "api/lights.html#slam-shift",
    "href": "api/lights.html#slam-shift",
    "title": "Lights",
    "section": "Slam shift",
    "text": "Slam shift\nLightSchedule.SlamShift approximates the light schedule that slam shift workers experience when changing shifts. The schedule starts with before_days where the worker is on a regular schedule and then shifts to a new schedule by shift hours. Before the shift happens, there’s a transition via sleep banking. The default schedule is:\n\nslam_shift = LightSchedule.SlamShift()\nax = slam_shift.plot(0.0, 24.0*12.0)\nax.set_xlabel('Time (hours)');\nax.set_ylabel('Light (lux)');\nax.figure.set_size_inches(16, 4);\n# add a vertical line to the start of each day in dashed gray\nfor day in range(13):\n    ax.axvline(day*24.0, color='gray', linestyle='--');\nax.set_xticks(np.arange(0, 24.0*12.0, 12));\n# set background color to light red for the days before the shift\nax.axvspan(0.0, 24.0*5, facecolor='r', alpha=0.1, label='Before shift');\n# set background color to light green for days after the shift\nax.axvspan(24.0*5, 24.0*12.0, facecolor='g', alpha=0.1, label='After shift');\n# place legend at the top of the plot\nax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.15), ncol=2);\nax.set_xlim(0.0, 24.0*12.0);"
  },
  {
    "objectID": "api/lights.html#social-jet-lag",
    "href": "api/lights.html#social-jet-lag",
    "title": "Lights",
    "section": "Social jet lag",
    "text": "Social jet lag\nLightSchedule.SocialJetlag implements a light schedule where the person stays up late on weekends while maintaining a regular schedule during the week. The schedule is periodic over the sum of num_regular_days and num_jetlag_days.\n\nsocial_jetlag = LightSchedule.SocialJetlag()\nax = social_jetlag.plot(0.0, 24.0*8.0)\nax.set_xlabel('Time (hours)');\nax.set_ylabel('Light (lux)');\nax.figure.set_size_inches(16, 4);\n# add a vertical line to the start of each day in dashed gray\nfor day in range(9):\n    ax.axvline(day*24.0, color='gray', linestyle='--');\nax.set_xticks(np.arange(0, 24.0*8.0, 12));\n# set background color to light red for the regular days\nax.axvspan(0.0, 24.0*5, facecolor='r', alpha=0.1, label='Regular days');\nax.axvspan(24.0*7, 24.0*8.0, facecolor='r', alpha=0.1);\n# set background color to light green for days with jetlag\nax.axvspan(24.0*5, 24.0*7.0, facecolor='g', alpha=0.1, label='Social Jetlag days');\n# place legend at the top of the plot\nax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.15), ncol=2);\nax.set_xlim(0.0, 24.0*8.0);"
  },
  {
    "objectID": "api/phasetools.html",
    "href": "api/phasetools.html",
    "title": "Phase Tools",
    "section": "",
    "text": "The simplest and one of the most popular techniques is so-called cosinor analysis, which is a very fancy term for doing a linear regression on cosine transformed data.\n\\[ y = A \\cos(x + \\beta) \\]\nor in the form that I prefer:\n\\[q(t,\\phi) = a_1 \\sin(\\omega t) + a_2 \\cos(\\omega t) \\]\nIn cosinor analysis the \\(\\omega\\) term (the frequency) is taken as a known quantity and the \\(a_{1,2}\\) terms are fit to minimize the least square error.\nThen the phase \\(\\phi\\) is given by \\(\\arg(a_2 + i a_1)\\)\n\ndef f_signal_cosinor(t: np.array, phi: float, tau: float = 100.0) -&gt; np.array:\n    return np.cos(2 * np.pi/tau * t - phi)\n\nphi_true = 2.0\nx_sample = np.arange(0, 200, 5)\ny_sample = f_signal_cosinor(x_sample, phi_true) \ny_sample_noisy = y_sample + np.random.normal(0, 0.5, x_sample.shape)\n\nplt.scatter(x_sample,y_sample_noisy, color='k', s=20, label='Noisy Measurements')\nplt.plot(x_sample, y_sample, ls = '--', color = 'k', label = 'True Signal');\nplt.legend()\nplt.title('Cosinor Example Signal with Noise');\n\n\n\n\nExample Cosinor Data\n\n\n\n\nIt is easy enough to use built in regression functions to find \\(a_{1,2}\\) but we can easily solve this ourselves. First, lets define the terms \\(y\\) is the signal, \\(t\\) is the sampling times the same length as \\(y\\). The matrix \\(S\\) is formed by taking the sin/cos of the time vectors and placing them in the columns \\(S = [sin(\\omega t); cos(\\omega t)]\\). Thus, we can write our system as:\n\\[ S a = y \\]\nwhere \\(a = [a_1, a_2]\\) are the two coefficients we want to solve for. This regression is especially easy to compute in this case because the matrix \\(S\\) has the property that the columns are orthogonal (S is a orthogonal matrix). This means that \\(S^T S = I\\), and we can solve the system with one matrix transpose multiplication.\n\\[\\begin{align}\nSa = y \\\\\nS^T S a = S^T y, S^T S = I \\\\\na = S^T y\n\\end{align}\\]\nSince \\(S^T\\) only has two columns we can write the matrix-vector product out for each component:\n\\[\\begin{align}\na_1 = \\frac{ \\sin(\\omega t) \\cdot y}  { || \\sin(\\omega t) ||^2 } \\\\\na_2 = \\frac { \\cos(\\omega t) \\cdot y } { || \\cos(\\omega t) ||^2 }\n\\end{align}\\] Here is a quick implementation in python.\n\na_coeffs = cosinor(x_sample, y_sample_noisy, 100.0)\nprint(f\"Recovered Cosinor Parameters {a_coeffs[0]:.4f} sin(omega t) + {a_coeffs[1]:.4f} cos(omega t)\")\nprint(f\"Phase Estimate: {cosinor_phase(a_coeffs):.4f} versus the true phase: {phi_true:.4f}\")\n\n\nplt.scatter(x_sample,y_sample_noisy, color='k', s=20, label='Noisy Measurements')\nplt.plot(x_sample, y_sample, ls = '--', color = 'k', label = 'True Signal')\nplt.plot(x_sample, a_coeffs[0]*np.sin(2*np.pi/100.0 *x_sample) + a_coeffs[1]*np.cos(2*np.pi/100.0 *x_sample), ls = '--', color = 'r', label = 'Cosinor Fit');\nplt.legend()\nplt.title('Cosinor Example Signal with Noise');\n\nRecovered Cosinor Parameters 0.8104 sin(omega t) + -0.2875 cos(omega t)\nPhase Estimate: 1.9117 versus the true phase: 2.0000\n\n\n\n\n\n\n\nOne of the main challenges with the cosinor method is that it assumes that the data is continuous. This is not always the case. For example, if you are measuring a signal at a fixed time interval, but the signal is not present at all times, then you will have gaps in your data.\nThe GOALs algorithm (citation) is a modification of the cosinor method that allows for gaps in the data.\n\nphi_true = 2.0\nx_sample = np.hstack((np.arange(0, 20, 1), np.arange(40, 60, 1)))\ny_sample = f_signal_cosinor(x_sample, phi_true) \ny_sample_noisy = y_sample + np.random.normal(0, 0.5, x_sample.shape)\n\na_coeffs = cosinor_goals(x_sample, y_sample_noisy, 100.0)\nprint(f\"Recovered GOALS Cosinor Parameters {a_coeffs[0]:.4f} sin(omega t) + {a_coeffs[1]:.4f} cos(omega t)\")\nprint(f\"GOALS Phase Estimate: {cosinor_phase(a_coeffs):.4f} versus the true phase: {phi_true:.4f}\")\n\n\na_coeffs_plain = cosinor(x_sample, y_sample_noisy, 100.0)\nprint(f\"Recovered Cosinor Parameters {a_coeffs_plain[0]:.4f} sin(omega t) + {a_coeffs_plain[1]:.4f} cos(omega t)\")\nprint(f\"Regular Cosinor Phase Estimate: {cosinor_phase(a_coeffs_plain):.4f} versus the true phase: {phi_true:.4f}\")\n\nx_fill = np.arange(0, 100, 1)\ny_fill = f_signal_cosinor(x_fill, phi_true)\nplt.scatter(x_sample,y_sample_noisy, color='k', s=20, label='Noisy Measurements')\nplt.plot(x_fill, y_fill, ls = '--', color = 'k', label = 'True Signal')\nplt.plot(x_fill, a_coeffs[0]*np.sin(2*np.pi/100.0 *x_fill) + a_coeffs[1]*np.cos(2*np.pi/100.0 *x_fill), ls = '--', color = 'r', label = 'GOALs Cosinor Fit');\nplt.plot(x_fill, a_coeffs_plain[0]*np.sin(2*np.pi/100.0 *x_fill) + a_coeffs_plain[1]*np.cos(2*np.pi/100.0 *x_fill), ls = '--', color = 'b', label = 'Cosinor Fit');\nplt.legend()\nplt.title('Cosinor (GOALS) Example Signal with Noise');\n\nRecovered GOALS Cosinor Parameters 0.4250 sin(omega t) + -0.3013 cos(omega t)\nGOALS Phase Estimate: 2.1875 versus the true phase: 2.0000\nRecovered Cosinor Parameters 0.6239 sin(omega t) + -0.1410 cos(omega t)\nRegular Cosinor Phase Estimate: 1.7931 versus the true phase: 2.0000"
  },
  {
    "objectID": "api/phasetools.html#goals-cosinor-with-gaps",
    "href": "api/phasetools.html#goals-cosinor-with-gaps",
    "title": "Phase Tools",
    "section": "",
    "text": "One of the main challenges with the cosinor method is that it assumes that the data is continuous. This is not always the case. For example, if you are measuring a signal at a fixed time interval, but the signal is not present at all times, then you will have gaps in your data.\nThe GOALs algorithm (citation) is a modification of the cosinor method that allows for gaps in the data.\n\nphi_true = 2.0\nx_sample = np.hstack((np.arange(0, 20, 1), np.arange(40, 60, 1)))\ny_sample = f_signal_cosinor(x_sample, phi_true) \ny_sample_noisy = y_sample + np.random.normal(0, 0.5, x_sample.shape)\n\na_coeffs = cosinor_goals(x_sample, y_sample_noisy, 100.0)\nprint(f\"Recovered GOALS Cosinor Parameters {a_coeffs[0]:.4f} sin(omega t) + {a_coeffs[1]:.4f} cos(omega t)\")\nprint(f\"GOALS Phase Estimate: {cosinor_phase(a_coeffs):.4f} versus the true phase: {phi_true:.4f}\")\n\n\na_coeffs_plain = cosinor(x_sample, y_sample_noisy, 100.0)\nprint(f\"Recovered Cosinor Parameters {a_coeffs_plain[0]:.4f} sin(omega t) + {a_coeffs_plain[1]:.4f} cos(omega t)\")\nprint(f\"Regular Cosinor Phase Estimate: {cosinor_phase(a_coeffs_plain):.4f} versus the true phase: {phi_true:.4f}\")\n\nx_fill = np.arange(0, 100, 1)\ny_fill = f_signal_cosinor(x_fill, phi_true)\nplt.scatter(x_sample,y_sample_noisy, color='k', s=20, label='Noisy Measurements')\nplt.plot(x_fill, y_fill, ls = '--', color = 'k', label = 'True Signal')\nplt.plot(x_fill, a_coeffs[0]*np.sin(2*np.pi/100.0 *x_fill) + a_coeffs[1]*np.cos(2*np.pi/100.0 *x_fill), ls = '--', color = 'r', label = 'GOALs Cosinor Fit');\nplt.plot(x_fill, a_coeffs_plain[0]*np.sin(2*np.pi/100.0 *x_fill) + a_coeffs_plain[1]*np.cos(2*np.pi/100.0 *x_fill), ls = '--', color = 'b', label = 'Cosinor Fit');\nplt.legend()\nplt.title('Cosinor (GOALS) Example Signal with Noise');\n\nRecovered GOALS Cosinor Parameters 0.4250 sin(omega t) + -0.3013 cos(omega t)\nGOALS Phase Estimate: 2.1875 versus the true phase: 2.0000\nRecovered Cosinor Parameters 0.6239 sin(omega t) + -0.1410 cos(omega t)\nRegular Cosinor Phase Estimate: 1.7931 versus the true phase: 2.0000"
  },
  {
    "objectID": "api/prc.html",
    "href": "api/prc.html",
    "title": "PRC",
    "section": "",
    "text": "model = Hannay19()\n\nlight_schedule = LightSchedule.Regular(lux=1000.0)\ntime = np.arange(0.0, 24.0, 0.10) \nlight = light_schedule(time)\ninitial_conditions = model.equilibrate(time, input=light, num_loops=100)\n\nphases = [] \nshifts = [] \nfor cr in PRCFinder().type0x:\n    phase,shift = PRCFinder.prc_type0_point(cr, initial_conditions, model)\n    phases.append(phase)\n    if shift &gt; 12.0:\n        shift -= 24.0\n    shifts.append(shift)\n\nxVals = np.arange(0,24,0.1)\nyVals = np.array([PRCFinder.exp_type0(x, 10.0) for x in xVals])\nplt.scatter(phases, shifts, color='black');\nplt.plot(xVals, yVals, color='black', ls='--');\n\nplt.title(\"Type 0 Human PRC\");\nplt.xlabel(\"Phase\") \nplt.ylabel(\"Phase Shift\")\n\nC:\\Users\\tavel\\AppData\\Local\\Temp\\ipykernel_14516\\3293739244.py:26: RuntimeWarning: divide by zero encountered in scalar divide\n  val=(-1.57154+0.228932/(-1.0*b+x)-0.650632*x)*heaviside(b-x)+(9.66876+0.1321196/(-1.0*b+x)-0.463105*x)*heaviside(x-b)\n\n\nText(0, 0.5, 'Phase Shift')"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Circadian",
    "section": "",
    "text": "Welcome to circadian, a computational package for the simulation and analysis of circadian rhythms"
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "Circadian",
    "section": "Install",
    "text": "Install\ncircadian can be installed via pip:\npip install circadian"
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Circadian",
    "section": "Overview",
    "text": "Overview\nThe circadian package implements key mathematical models in the field such as:\n\nForger99 - Forger et al. (1999)\nHannay19 and Hannay19TP - Hannay et al. (2019)\nJewett99 - Kronauer et al. (1999)\n\nSee all the available models at circadian/models.py\nAdditionally, circadian provides a set of tools for simulating and analzying circadian rhythms:\n\nDefine light schedules using the Light class and feed directly into the models\nCalculate phase response curves using the PRCFinder class\nGenerate actograms and phase plots with the circadian.plots module\n\nFinally, the package streamlines the process of reading, processing, and analyzing wereable data via the circadian.readers module.\nCheck out the documentation for a full overview of the package and its features."
  },
  {
    "objectID": "index.html#example",
    "href": "index.html#example",
    "title": "Circadian",
    "section": "Example",
    "text": "Example\nThe code below shows how to simulate the circadian rhythm of a shift worker for four different models and visualize the results in an actogram plot\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as lines\nfrom circadian.plots import Actogram\nfrom circadian.lights import LightSchedule\nfrom circadian.models import Forger99, Jewett99, Hannay19, Hannay19TP\n\ndays_night = 3\ndays_day = 2\nslam_shift = LightSchedule.ShiftWork(lux=300.0, days_on=days_night, days_off=days_day)\n\ntotal_days = 30\ntime = np.arange(0, 24*total_days, 0.10)\nlight_values = slam_shift(time)\n\nf_model = Forger99()\nkj_model = Jewett99()\nspm_model = Hannay19()\ntpm_model = Hannay19TP()\n\nequilibration_reps = 2\ninitial_conditions_forger = f_model.equilibrate(time, light_values, equilibration_reps)\ninitial_conditions_kj = kj_model.equilibrate(time, light_values, equilibration_reps)\ninitial_conditions_spm = spm_model.equilibrate(time, light_values, equilibration_reps)\ninitial_conditions_tpm = tpm_model.equilibrate(time, light_values, equilibration_reps)\n\nThe models are integrated using an explicit Runge-Kutta 4 (RK4) scheme\n\ntrajectory_f = f_model(time, initial_conditions_forger, light_values)\ntrajectory_kj = kj_model(time, initial_conditions_kj, light_values)\ntrajectory_spm = spm_model(time, initial_conditions_spm, light_values)\ntrajectory_tpm = tpm_model(time, initial_conditions_tpm, light_values)\n\nThe Dim Light Melatonin Onset (DLMO), an experimental measurement of circadian phase, is calculated for each model by\n\ndlmo_f = f_model.dlmos()\ndlmo_kj = kj_model.dlmos()\ndlmo_spm = spm_model.dlmos()\ndlmo_tpm = tpm_model.dlmos()\n\nLastly, the results of the simulation–DLMOs included– are visualized in an Actogram plot from the circadian.plots module\n\nacto = Actogram(time, light_vals=light_values, opacity=1.0, smooth=False)\nacto.plot_phasemarker(dlmo_f, color='blue')\nacto.plot_phasemarker(dlmo_spm, color='darkgreen')\nacto.plot_phasemarker(dlmo_tpm, color='red')\nacto.plot_phasemarker(dlmo_kj, color='purple')\n# legend\nblue_line = lines.Line2D([], [], color='blue', label='Forger99')\ngreen_line = lines.Line2D([], [], color='darkgreen', label='Hannay19')\nred_line = lines.Line2D([], [], color='red', label='Hannay19TP')\npurple_line = lines.Line2D([], [], color='purple', label='Jewett99')\n\nplt.legend(handles=[blue_line, purple_line, green_line, red_line], \n           loc='upper center', bbox_to_anchor=(0.5, 1.12), ncol=4)\nplt.title(\"Actogram for a Simulated Shift Worker\", pad=35)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "api/utils.html#data-related-utils",
    "href": "api/utils.html#data-related-utils",
    "title": "Utilities",
    "section": "Data related utils",
    "text": "Data related utils\nThis function can be used to redact the dates from a json file, this is to protect the user privacy. The start of the timestamps will be set back to the unix epoch time."
  },
  {
    "objectID": "api/plots.html",
    "href": "api/plots.html",
    "title": "Plots",
    "section": "",
    "text": "Actograms help display periodic trends in data.\n\n\n\n\n\n\nNote\n\n\n\nI prefer my actograms to show low values as black and high values as white. The convention in circadian science (for some reason) is the reverse. This can easily be switched in plot calls if you want to do things the wrong way.\n\n\n\nslam_shift = LightSchedule.SlamShift() \ntime = np.arange(0, 20*24.0, 0.10)\nlight_values = slam_shift(time) \n\nact = Actogram(time, light_vals=light_values, smooth=False)\n\nspm = Hannay19()\ntrajectory = spm(time, np.array([1.0, np.pi, 0.0]), light_values)\ndlmo = spm.dlmos()\n\nact.plot_phasemarker(dlmo, color='blue')\nplt.show()\n\n\n\n\n\ndlmo_experimental = np.linspace(-12, 12., 30) \ndlmo_predicted = dlmo_experimental + np.random.normal(0, 2, len(dlmo_experimental))\n\nplot_mae(dlmo_experimental, dlmo_predicted)\n\nThe MAE is: 4.893222072754772\nWithin one hour 7/30\n[-3.47328784e+00  2.29203680e+01  2.14370972e+01  2.05151476e+01\n -8.28809784e-01  3.29152432e+00 -1.03521731e+00 -1.21786907e+00\n  6.01046181e-01 -8.64421152e-01  2.32069554e+00 -1.20140297e+00\n  1.11533503e+00 -1.35758354e+00 -1.13861312e+00  1.62675565e+00\n  1.03264169e+00  1.65883693e+00  1.66964836e+00 -2.41250659e+00\n  3.98410068e-01  2.24680534e+00  4.61070620e-01 -1.11127185e-02\n  8.78906427e-02  1.18376113e+00  1.25223210e+00 -2.07873084e+01\n -2.31041479e+01 -5.54511532e+00]\n\n\n\n\n\nHere is an example of the torus plot, which allows one to visualize the relationsjip between two phases.\n\nphi1 = 12.0 + 5.0*np.random.randn(100) \nphi2 = phi1 + 5.0*np.random.randn(100)\n\nplot_torus(phi1, phi2, scaled_by=24.0, color='darkgreen')\nplt.title(\"Example torus plot\")\nplt.xlabel(\"$\\phi_1$\") \nplt.ylabel(\"$\\phi_2$\");\n\n\n\n\nExample of an actogram\nThis is how you can visualize entrainment using a Stroboscopic plot of a trajectory\n\nslam_shift = LightSchedule.SlamShift(shift=12.0, lux=500.0, before_days=2) \ntime = np.arange(0.0, 15*24.0, 0.10)\nlight_values = slam_shift(time)\n# Run this for a range of period parameters \nbatch_dim = 50\nhmodel = Hannay19({'tau': np.linspace(23.5, 24.5, batch_dim)}) \n\ninitial_state = np.array([1.0, np.pi, 0.0]) + np.zeros((batch_dim, 3))\ninitial_state = initial_state.T\ntrajectory = hmodel(time, initial_state, light_values)\n\nax = plt.gca()\ncmap = plt.get_cmap('jet')\nfor idx in range(trajectory.batch_size):\n    Stroboscopic(ax, \n                 time, \n                 trajectory.states[:, 0, idx], \n                 trajectory.states[:, 1, idx], \n                 period=24.0, \n                 lw=0.50,\n                 color=cmap(idx/batch_dim));\nplt.title(\"Stroboscopic plot of the Hannay et al. 2019 model\");\n\n\n\n\n\nslam_shift = LightSchedule.ShiftWork() \ntime = np.arange(0, 30*24.0, 0.10)\nlight_values = slam_shift(time) + np.random.randn(len(time)) * 1.0\n\nfig, ax = plt.subplots(1, 2, sharey='row')\nact = plot_actogram(ax[0], zeitgeber=light_values, cmap='viridis')\nact = plot_actogram(ax[1], zeitgeber=light_values)\n\nfig.subplots_adjust(wspace=0, hspace=0)"
  },
  {
    "objectID": "api/plots.html#actograms",
    "href": "api/plots.html#actograms",
    "title": "Plots",
    "section": "",
    "text": "Actograms help display periodic trends in data.\n\n\n\n\n\n\nNote\n\n\n\nI prefer my actograms to show low values as black and high values as white. The convention in circadian science (for some reason) is the reverse. This can easily be switched in plot calls if you want to do things the wrong way.\n\n\n\nslam_shift = LightSchedule.SlamShift() \ntime = np.arange(0, 20*24.0, 0.10)\nlight_values = slam_shift(time) \n\nact = Actogram(time, light_vals=light_values, smooth=False)\n\nspm = Hannay19()\ntrajectory = spm(time, np.array([1.0, np.pi, 0.0]), light_values)\ndlmo = spm.dlmos()\n\nact.plot_phasemarker(dlmo, color='blue')\nplt.show()\n\n\n\n\n\ndlmo_experimental = np.linspace(-12, 12., 30) \ndlmo_predicted = dlmo_experimental + np.random.normal(0, 2, len(dlmo_experimental))\n\nplot_mae(dlmo_experimental, dlmo_predicted)\n\nThe MAE is: 4.893222072754772\nWithin one hour 7/30\n[-3.47328784e+00  2.29203680e+01  2.14370972e+01  2.05151476e+01\n -8.28809784e-01  3.29152432e+00 -1.03521731e+00 -1.21786907e+00\n  6.01046181e-01 -8.64421152e-01  2.32069554e+00 -1.20140297e+00\n  1.11533503e+00 -1.35758354e+00 -1.13861312e+00  1.62675565e+00\n  1.03264169e+00  1.65883693e+00  1.66964836e+00 -2.41250659e+00\n  3.98410068e-01  2.24680534e+00  4.61070620e-01 -1.11127185e-02\n  8.78906427e-02  1.18376113e+00  1.25223210e+00 -2.07873084e+01\n -2.31041479e+01 -5.54511532e+00]\n\n\n\n\n\nHere is an example of the torus plot, which allows one to visualize the relationsjip between two phases.\n\nphi1 = 12.0 + 5.0*np.random.randn(100) \nphi2 = phi1 + 5.0*np.random.randn(100)\n\nplot_torus(phi1, phi2, scaled_by=24.0, color='darkgreen')\nplt.title(\"Example torus plot\")\nplt.xlabel(\"$\\phi_1$\") \nplt.ylabel(\"$\\phi_2$\");\n\n\n\n\nExample of an actogram\nThis is how you can visualize entrainment using a Stroboscopic plot of a trajectory\n\nslam_shift = LightSchedule.SlamShift(shift=12.0, lux=500.0, before_days=2) \ntime = np.arange(0.0, 15*24.0, 0.10)\nlight_values = slam_shift(time)\n# Run this for a range of period parameters \nbatch_dim = 50\nhmodel = Hannay19({'tau': np.linspace(23.5, 24.5, batch_dim)}) \n\ninitial_state = np.array([1.0, np.pi, 0.0]) + np.zeros((batch_dim, 3))\ninitial_state = initial_state.T\ntrajectory = hmodel(time, initial_state, light_values)\n\nax = plt.gca()\ncmap = plt.get_cmap('jet')\nfor idx in range(trajectory.batch_size):\n    Stroboscopic(ax, \n                 time, \n                 trajectory.states[:, 0, idx], \n                 trajectory.states[:, 1, idx], \n                 period=24.0, \n                 lw=0.50,\n                 color=cmap(idx/batch_dim));\nplt.title(\"Stroboscopic plot of the Hannay et al. 2019 model\");\n\n\n\n\n\nslam_shift = LightSchedule.ShiftWork() \ntime = np.arange(0, 30*24.0, 0.10)\nlight_values = slam_shift(time) + np.random.randn(len(time)) * 1.0\n\nfig, ax = plt.subplots(1, 2, sharey='row')\nact = plot_actogram(ax[0], zeitgeber=light_values, cmap='viridis')\nact = plot_actogram(ax[1], zeitgeber=light_values)\n\nfig.subplots_adjust(wspace=0, hspace=0)"
  },
  {
    "objectID": "api/models.html",
    "href": "api/models.html",
    "title": "Models",
    "section": "",
    "text": "The circadian.models module contains the essential tools for simulating circadian rhythms. The base class DynamicalTrajectory handles differential equation solutions, while the CircadianModel class handles the implementation of the models themselves. The first part of the documentation focuses on how to simulate circadian rhythms while the second part describes each model briefly. For a description of each implementation see the API Documentation."
  },
  {
    "objectID": "api/models.html#custom-parameters-and-initial-conditions",
    "href": "api/models.html#custom-parameters-and-initial-conditions",
    "title": "Models",
    "section": "Custom parameters and initial conditions",
    "text": "Custom parameters and initial conditions\nIn the example above, we are not defining initial conditions nor parameters. This is because each model in the library has a default set of parameters and initial conditions. Initial conditions and parameters used in the simulation can be accessed by\n\nmodel.initial_condition\n\narray([-0.0843259 , -1.09607546,  0.45584306])\n\n\n\nmodel.parameters\n\n{'taux': 24.2,\n 'mu': 0.23,\n 'G': 33.75,\n 'alpha_0': 0.05,\n 'beta': 0.0075,\n 'p': 0.5,\n 'I0': 9500.0,\n 'k': 0.55,\n 'cbt_to_dlmo': 7.0}\n\n\nWe can run simulations with custom parameters and initial conditions by\n\nsimulation_days = 5\ndt = 0.5 # hours\ntime = np.arange(0, 24 * simulation_days, dt)\n\nlight_schedule = LightSchedule.Regular()\nlight_input = light_schedule(time)\n\ncustom_parameters = {\n    'taux': 14.0, 'mu': 0.3, 'G': 34.0, 'alpha_0': 0.07,\n    'delta': 0.0095, 'p': 0.7, 'I0': 9300.0, 'kparam': 0.75,\n    'cbt_to_dlmo': 7.0}\ncustom_initial_condition = np.array([0.5, 0.1, 0.1])\n\nmodel = Forger99(custom_parameters)\ntrajectory = model(time, custom_initial_condition, light_input)\n\n\nplt.plot(time/24.0, trajectory.states[:,0], label='x')\nplt.xlabel('Time (days)')\nplt.ylabel('State')\nplt.show()\n\n\n\n\nWhen defining custom parameters we can specify only a subset and the rest will maintain their default values (or any previously defined values).\n\nsimulation_days = 5\ndt = 0.5 # hours\ntime = np.arange(0, 24 * simulation_days, dt)\n\nlight_schedule = LightSchedule.Regular()\nlight_input = light_schedule(time)\n\nmodel = Forger99({'taux': 48.0})\ntrajectory = model(time,  input=light_input)"
  },
  {
    "objectID": "api/models.html#simulating-from-multiple-initial-conditions",
    "href": "api/models.html#simulating-from-multiple-initial-conditions",
    "title": "Models",
    "section": "Simulating from multiple initial conditions",
    "text": "Simulating from multiple initial conditions\nModels accept arrays of initial conditions allowing to simulate from multiple initial conditions at once. For example, to simulate the Forger99 model from 100 different initial conditions we can do\n\nsimulation_days = 10\ndt = 0.5 # hours\ntime = np.arange(0, 24 * simulation_days, dt)\n\nlight_schedule = LightSchedule.Regular()\nlight_input = light_schedule(time)\n\nx_values = np.linspace(-1.0, 1.0, 10)\nxc_values = np.linspace(-1.0, 1.0, 10)\nx_xc_stack = np.dstack(np.meshgrid(x_values, xc_values)).reshape(-1, 2)\nmultiple_initial_conditions = np.hstack((x_xc_stack, np.zeros((x_xc_stack.shape[0], 1))))\nmultiple_initial_conditions = multiple_initial_conditions.T\n\nmodel = Forger99()\ntrajectory = model(time, multiple_initial_conditions, light_input)\n\nNote that we have to format the initial conditions as a numpy array of dimensions (3, n) where n is the total number of initial conditions and 3 is the number of states in the model.\nThe resulting trajectory contains all the solutions in the same order as the initial conditions\n\ntrajectory.states.shape\n\n(480, 3, 100)\n\n\nWe can plot the solution for each initial condition by\n\nfor idx in range(trajectory.states.shape[2]):\n    plt.plot(time/24.0, trajectory.states[:,0,idx], \n             color='b', alpha=0.1)\nplt.xlabel('Time (days)')\nplt.ylabel('State')\nplt.show()\n\n\n\n\nThis is the recommended method to simulate multiple initial conditions–by passing a numpy array to the model. Our implementation takes advantage of numpy’s vectorization to speed up the calculation. If we simulate each initial condition individually, the simulation will be slower."
  },
  {
    "objectID": "api/models.html#estimation-of-circadian-phase-markers",
    "href": "api/models.html#estimation-of-circadian-phase-markers",
    "title": "Models",
    "section": "Estimation of circadian phase markers",
    "text": "Estimation of circadian phase markers\nModels support the estimation of Dim Light Melatonin Onset (DLMO) and Core Body Temperature Minimum (CBTmin) directly from the solution\n\nsimulation_days = 5\ndt = 0.5 # hours\ntime = np.arange(0, 24 * simulation_days, dt)\n\nlight_schedule = LightSchedule.Regular()\nlight_input = light_schedule(time)\n\nmodel = Forger99()\ntrajectory = model(time, input=light_input)\n\ncbt_times = model.cbt()\ndlmo_times = model.dlmos()"
  },
  {
    "objectID": "api/models.html#amplitude-and-phase-calculation",
    "href": "api/models.html#amplitude-and-phase-calculation",
    "title": "Models",
    "section": "Amplitude and phase calculation",
    "text": "Amplitude and phase calculation\nModels also support the calculation of amplitude and phase at any desired timepoint\n\nsimulation_days = 5\ndt = 0.5 # hours\ntime = np.arange(0, 24 * simulation_days, dt)\n\nlight_schedule = LightSchedule.Regular()\nlight_input = light_schedule(time)\n\nmodel = Forger99()\ntrajectory = model(time, input=light_input)\n\nt_final = time[-1]\nfinal_phase = model.phase(time=t_final)\nfinal_amplitude = model.amplitude(time=t_final)\n\nFinal phase: 1.816519098567579\nFinal amplitude: 1.0736079380242345"
  },
  {
    "objectID": "api/models.html#forger99",
    "href": "api/models.html#forger99",
    "title": "Models",
    "section": "Forger99",
    "text": "Forger99\nThe Forger99 model is taken from Forger, Jewett, and Kronauer’s 1999 article which defines a simplification of previous iterations of the van der Pol based oscillator models published in the 1990s. It is one of the most popular models in the circadian literature. The implementation in this package uses the parameters taken from Serkh and Forger 2014 rather than the parameters from the original paper.\nThe model states are defined by three dynamic variables: \\(x\\), \\(x_c\\), and \\(n\\). These states are related to circadian rhythms by defining the core body temperature minimum (a biomarker for circadian state) to be the minimum of the \\(x\\) variable.\nThe differential equations governing the evolution of the Forger99 model are:\n\\(\\frac{dx}{dt} = \\frac{\\pi}{12}(x_c + B)\\)\n\\(\\frac{dx_c}{dt} = \\frac{\\pi}{12}\\left\\{\\mu \\left( x_c - \\frac{4x_{c}^3}{3} \\right) - x \\left[ \\left( \\frac{24}{0.99669 \\tau_x} \\right)^2 + kB \\right] \\right\\}\\)\n\\(\\frac{dn}{dt} = 60[\\alpha(I)(1-n)-\\beta n]\\)\nwhere\n\\(\\alpha(I) = \\alpha_0\\left( \\frac{I^p}{I_0^p}\\right)\\)\n\\(B = G(1-n)\\alpha(I)(1-0.4x)(1-0.4x_c)\\)\nThe default parameters for this model are:\n\nmodel = Forger99()\nmodel.parameters\n\n{'taux': 24.2,\n 'mu': 0.23,\n 'G': 33.75,\n 'alpha_0': 0.05,\n 'beta': 0.0075,\n 'p': 0.5,\n 'I0': 9500.0,\n 'k': 0.55,\n 'cbt_to_dlmo': 7.0}\n\n\nThe cbt_to_dlmo parameter is used to convert the core body temperature minimum to DLMO. The default behavior is DLMO ocurring 7 hours before CBTmin."
  },
  {
    "objectID": "api/models.html#jewett99",
    "href": "api/models.html#jewett99",
    "title": "Models",
    "section": "Jewett99",
    "text": "Jewett99\nThe Jewett99 model is taken from Jewett, Forger, and Kronauer’s 1999 article which defines several refinements to a van der Pol oscillator model developed by Kronauer previously. One of the main features of this model are the high-order terms in the differential equations which allow for a more accurate representation of the circadian system than previous models.\nSimilarly to Forger99 the model states are defined by three dynamic variables: \\(x\\), \\(x_c\\), and \\(n\\). The variable \\(x\\) is related to the core body temperature and \\(n\\) to the processed light input.\nThe differential equations governing the evolution of the Jewett99 model are:\n\\(\\frac{dx}{dt} = \\frac{\\pi}{12} \\left[x_c + \\mu \\left(\\frac{x}{3} + \\frac{4x^3}{3} - \\frac{256 x^7}{105}\\right) + B\\right]\\)\n\\(\\frac{dx_c}{dt} = \\frac{\\pi}{12} \\left\\{ q B x_c - \\left[ \\left( \\frac{24}{0.99729 \\tau_{x}} \\right)^2 + k B \\right] x \\right\\}\\)\n\\(\\frac{dn}{dt} = 60[\\alpha(I)(1-n)-\\beta n]\\)\nwhere\n\\(\\alpha(I) = \\alpha_0\\left( \\frac{I^p}{I_0^p}\\right)\\)\n\\(B = G(1-n)\\alpha(I)(1-0.4x)(1-0.4x_c)\\)\nThe default parameters for this model are:\n\nmodel = Jewett99()\nmodel.parameters\n\n{'taux': 24.2,\n 'mu': 0.13,\n 'G': 19.875,\n 'beta': 0.013,\n 'k': 0.55,\n 'q': 0.3333333333333333,\n 'I0': 9500,\n 'p': 0.6,\n 'alpha_0': 0.16,\n 'phi_ref': 0.8,\n 'cbt_to_dlmo': 7.0}\n\n\nThe cbt_to_dlmo and phi_ref parameters are used to calculate the core body temperature minimum and convert it to DLMO. The CBTmin is calculated as the minimum of the \\(x\\) variable plus a shift of \\(\\phi_{\\text{ref}}=0.8\\) hours. The DLMO is calculated as CBTmin minus 7.0 hours."
  },
  {
    "objectID": "api/models.html#hannay19",
    "href": "api/models.html#hannay19",
    "title": "Models",
    "section": "Hannay19",
    "text": "Hannay19\nThe Hannay19 model is taken from Hannay, Booth, and Forger’s 2019 article. This model isn’t based on a van der Pol oscillator and instead it is systematically derived from a high-dimensional model for each clock neuron using the \\(m^2\\) ansatz (Hannay et al. 2018). The Hannay19 implementation corresponds to the single population model within the article.\nThe model describes the circadian state using polar coordinates and features a slight modification fo the light processing function found in van der Pol type models. Thus, the model states are defined by: \\(R\\), \\(\\psi\\), and \\(n\\).\nThe differential equations governing the evolution of the Hannay19 model are:\n\\(\\frac{dR}{dt} = - (D + \\gamma)R + \\frac{K}{2}cos(\\beta)R(1-R^4) + L_R(R, \\psi)\\)\n\\(\\frac{d\\psi}{dt} = \\omega_0 + \\frac{K}{2}sin(\\beta)(1+R^4) + L_{\\psi}(R,\\psi)\\)\n\\(\\frac{dn}{dt} = 60\\left[\\alpha(I)(1-n)-\\delta n \\right]\\)\nwhere\n\\(L_R(R,\\psi) = \\frac{A_1}{2}B(t)(1-R^4)cos(\\psi + \\beta_{L1}) + \\frac{A_2}{2}B(t)R(1-R^8)cos(2\\psi + \\beta_{L2})\\)\n\\(L_{\\psi}(R, \\psi) = \\sigma B(t) - \\frac{A_1}{2}B(t)\\left(\\frac{1}{R} + R^3 \\right)\\sin(\\psi + \\beta_{L1}) - \\frac{A_2}{2}B(t)(1+R^8)\\sin(2\\psi + \\beta_{L2})\\)\n\\(\\alpha(I) = \\frac{\\alpha_0 I^p}{I^p + I_0}\\)\n\\(B(t) = G(1-n)\\alpha(L)\\)\nThe default parameters for this model are:\n\nmodel = Hannay19()\nmodel.parameters\n\n{'tau': 23.84,\n 'K': 0.06358,\n 'gamma': 0.024,\n 'Beta1': -0.09318,\n 'A1': 0.3855,\n 'A2': 0.1977,\n 'BetaL1': -0.0026,\n 'BetaL2': -0.957756,\n 'sigma': 0.0400692,\n 'G': 33.75,\n 'alpha_0': 0.05,\n 'delta': 0.0075,\n 'p': 1.5,\n 'I0': 9325.0,\n 'cbt_to_dlmo': 7.0}\n\n\nThe cbt_to_dlmo parameter is used to convert the core body temperature minimum to DLMO. The default behavior is DLMO ocurring 7 hours before CBTmin."
  },
  {
    "objectID": "api/models.html#hannay19tp",
    "href": "api/models.html#hannay19tp",
    "title": "Models",
    "section": "Hannay19TP",
    "text": "Hannay19TP\nThe Hannay19TP model comes from the same article as Hannay19 but stems from two populations of clock neurons rather than one. These two populations are the dorsal and ventral ones which define the model states to be: \\(R_v\\), \\(R_d\\), \\(\\psi_v\\), \\(\\psi_d\\), and \\(n\\).\nThe differential equations governing the evolution of the Hannay19TP model are:\n\\(\\frac{dR_v}{dt} = -\\gamma R_v + \\frac{K_{vv}}{2} R_v (1 - R_{v}^4) + \\frac{K_{dv}}{2}R_d (1 - R_{v}^4)\\cos(\\psi_d - \\psi_v) + L_R(R_v, \\psi_v)\\)\n\\(\\frac{dR_d}{dt} = -\\gamma R_d + \\frac{K_{dd}}{2} R_d (1 - R_{d}^4) + \\frac{K_{vd}}{2} R_v (1 - R_{d}^4)\\cos(\\psi_d - \\psi_v)\\)\n\\(\\frac{d\\psi_v}{dt} = \\omega_v + \\frac{K_{dv}}{2} R_d \\left( \\frac{1}{R_v} + R_{v}^3\\right)\\sin(\\psi_d - \\psi_v) + L_\\psi(R_v, \\psi_v)\\)\n\\(\\frac{d\\psi_d}{dt} = \\omega_d - \\frac{K_{vd}}{2} R_v \\left( \\frac{1}{R_d} + R_{d}^3\\right)\\sin(\\psi_d - \\psi_v)\\)\n\\(\\frac{dn}{dt} = 60\\left[\\alpha(I)(1-n)-\\delta n \\right]\\)\nwhere\n\\(L_R(R_v,\\psi_v) = \\frac{A_1}{2}B(t)(1-R_v^4)cos(\\psi_v + \\beta_{L1}) + \\frac{A_2}{2}B(t)R_v(1-R_v^8)cos(2\\psi_v + \\beta_{L2})\\)\n\\(L_{\\psi}(R_v, \\psi_v) = \\sigma B(t) - \\frac{A_1}{2}B(t)\\left(\\frac{1}{R_v} + R_v^3 \\right)\\sin(\\psi_v + \\beta_{L1}) - \\frac{A_2}{2}B(t)(1+R_v^8)\\sin(2\\psi_v + \\beta_{L2})\\)\n\\(\\alpha(I) = \\frac{\\alpha_0 I^p}{I^p + I_0}\\)\n\\(B(t) = G(1-n)\\alpha(L)\\)\nThe default parameters for this model are:\n\nmodel = Hannay19TP()\nmodel.parameters\n\n{'tauV': 24.25,\n 'tauD': 24.0,\n 'Kvv': 0.05,\n 'Kdd': 0.04,\n 'Kvd': 0.05,\n 'Kdv': 0.01,\n 'gamma': 0.024,\n 'A1': 0.440068,\n 'A2': 0.159136,\n 'BetaL': 0.06452,\n 'BetaL2': -1.38935,\n 'sigma': 0.0477375,\n 'G': 33.75,\n 'alpha_0': 0.05,\n 'delta': 0.0075,\n 'p': 1.5,\n 'I0': 9325.0,\n 'cbt_to_dlmo': 7.0}\n\n\nThe cbt_to_dlmo parameter is used to convert the core body temperature minimum to DLMO. The default behavior is DLMO ocurring 7 hours before CBTmin."
  },
  {
    "objectID": "api/models.html#hilaire07",
    "href": "api/models.html#hilaire07",
    "title": "Models",
    "section": "Hilaire07",
    "text": "Hilaire07\nThe Hilaire07 model is taken from Hilaire et al. 2007 which extends the Jewett99 model to include a non-photic input. The model states are defined by three dynamic variables: \\(x\\), \\(x_c\\), and \\(n\\) whereas the inputs are light and sleep/wake state. The variable \\(x\\) is related to the core body temperature and \\(n\\) to the processed light input.\nThe differential equations governing the evolution of the Hilaire07 model are:\n\\(\\frac{dx}{dt} = \\frac{\\pi}{12} \\left[x_c + \\mu \\left(\\frac{x}{3} + \\frac{4x^3}{3} - \\frac{256 x^7}{105}\\right) + B + N_{s}\\right]\\)\n\\(\\frac{dx_c}{dt} = \\frac{\\pi}{12} \\left\\{ q B x_c - \\left[ \\left( \\frac{24}{0.99729 \\tau_{x}} \\right)^2 + k B \\right] x \\right\\}\\)\n\\(\\frac{dn}{dt} = 60[\\alpha(I)(1-n)-\\beta n]\\)\nwhere\n\\(\\alpha(I) = \\alpha_0\\left( \\frac{I^p}{I_0^p}\\right) \\left( \\frac{I}{I + 100} \\right)\\)\n\\(B = G(1-n)\\alpha(I)(1-0.4x)(1-0.4x_c)\\)\n\\(N_{s} = \\hat{N}_{s} \\left[1 - \\tanh(10x) \\right]\\)\n\\(\\hat{N}_{s} = \\left\\{\\begin{matrix} \\frac{\\rho}{3} & \\text{if} \\ \\ \\ \\psi_{cx} \\in (16.5, 21.0) \\\\ (\\frac{1}{3} - \\sigma) \\rho & \\text{otherwise} \\end{matrix}\\right.\\)\n\\(\\psi_{cx} = \\left[ (t \\mod 24) - 24\\frac{\\phi_{xcx} + \\phi_{ref}}{2\\pi} \\right]\\mod 24\\)\n\\(\\sigma = \\left\\{\\begin{matrix} 1 & \\text{if asleep} \\\\ 0 & \\text{if awake} \\end{matrix}\\right.\\)\nNote that both \\(I\\) and \\(\\sigma\\) are inputs to the model\nThe default parameters for this model are:\n\nmodel = Hilaire07()\nmodel.parameters\n\n{'taux': 24.2,\n 'G': 37.0,\n 'k': 0.55,\n 'mu': 0.13,\n 'beta': 0.007,\n 'q': 0.3333333333333333,\n 'rho': 0.032,\n 'I0': 9500.0,\n 'p': 0.5,\n 'a0': 0.1,\n 'phi_xcx': -2.98,\n 'phi_ref': 0.97,\n 'cbt_to_dlmo': 7.0}\n\n\nThe cbt_to_dlmo and phi_ref parameters are used to calculate the core body temperature minimum and convert it to DLMO. The CBTmin is calculated as the minimum of the \\(x\\) variable plus a shift of \\(\\phi_{\\text{ref}}=0.97\\) hours. The DLMO is calculated as CBTmin minus 7.0 hours."
  },
  {
    "objectID": "api/models.html#skeldon23",
    "href": "api/models.html#skeldon23",
    "title": "Models",
    "section": "Skeldon23",
    "text": "Skeldon23\nThe Skeldon23 model is based on Skeldon et al. 2023 which combines a sleep pressure model with Forger99 to estimate realistic sleep/wake patterns. The model states are defined by four dynamic variables: \\(x\\), \\(x_c\\), \\(n\\), and \\(H\\). The variable \\(x\\) is related to the core body temperature, \\(n\\) to the processed light input, and \\(H\\) to the sleep pressure signal. Note that in our implementation we have favored Forger99’s notation of variables. In the original article, Skeldon et al. use variables \\(x\\) and \\(y\\) to indicate \\(x_c\\) and \\(x\\) respectively. Additionally, in this implementation, we have rescaled parameters to be defined in terms of hours rather than seconds. In addition to providing the states over time, the model also predicts sleep/wake patterns for each timepoint.\nThe differential equations governing the evolution of the Skeldon23 model are:\n\\(\\frac{dx}{dt} = \\frac{1}{\\kappa} \\left(x_c + B \\right)\\)\n\\(\\frac{dx_c}{dt} = \\frac{1}{\\kappa}\\left\\{\\gamma \\left( x_c - \\frac{4x_{c}^3}{3} \\right) - x \\left[ \\left( \\frac{24}{f \\tau_x} \\right)^2 + kB \\right] \\right\\}\\)\n\\(\\frac{dn}{dt} = 60[\\alpha(\\tilde{I})(1-n)-\\beta n]\\)\n$ = $\nwhere\n\\(S = \\left\\{\\begin{matrix} 1 & \\text{if asleep} \\\\ 0 & \\text{if awake} \\end{matrix}\\right.\\)\n\\(\\tilde{I} = (1 - S) I\\)\n\\(\\alpha(\\tilde{I}) = \\alpha_0\\left( \\frac{\\tilde{I}}{I_0}\\right)^p\\)\n\\(B = G(1-n)\\alpha(\\tilde{I})(1-bx)(1-bx_c)\\)\nthe variable \\(S\\) switches automatically based on the sleep pressure signal \\(H\\) and the circadian input to the sleep model \\(C\\):\n\\(C(t) = c_{20} + \\alpha_{21}x_{c} + \\alpha_{22}x + \\beta_{21}x_{c}^2 + \\beta_{22}x_{c}x + \\beta_{23}x^2\\)\nThe change from wake to sleep occurs when \\(H\\) reaches\n\\(H^{+}(t) = \\overline{H}_{0} + \\frac{\\Delta}{2} + c_{a} C(t)\\)\nand the change from sleep to wake occurs when \\(H\\) reaches\n\\(H^{-}(t) = \\overline{H}_{0} - \\frac{\\Delta}{2} + c_{a} C(t)\\)\nThe default parameters for this model are:\n\nmodel = Skeldon23()\nmodel.parameters\n\n{'mu': 17.78,\n 'chi': 45.0,\n 'H0': 13.0,\n 'Delta': 1.0,\n 'ca': 1.72,\n 'tauc': 24.2,\n 'f': 0.99669,\n 'G': 19.9,\n 'p': 0.6,\n 'k': 0.55,\n 'b': 0.4,\n 'gamma': 0.23,\n 'alpha_0': 0.16,\n 'beta': 0.013,\n 'I0': 9500.0,\n 'kappa': 3.819718634205488,\n 'c20': 0.7896,\n 'alpha21': -0.3912,\n 'alpha22': 0.7583,\n 'beta21': -0.4442,\n 'beta22': 0.025,\n 'beta23': -0.9647,\n 'S0': 0.0,\n 'cbt_to_dlmo': 7.0}\n\n\nThe cbt_to_dlmo parameter is used to convert the core body temperature minimum to DLMO. The default behavior is DLMO ocurring 7 hours before CBTmin."
  },
  {
    "objectID": "api/readers.html",
    "href": "api/readers.html",
    "title": "Readers",
    "section": "",
    "text": "Overview\nThe circadian.readers module contains several methods for working with wereable data such as step counts, heart rate, and sleep. It also defines a Pandas accessor called WereableData to standardize and validate wereable dataframes.\n\n\nLoading wereable data\nThe circadian.readers module provides functionality to import files in several formats, including raw CSV counts, JSON files, and data coming from Actiwatch readers in CSV format. For example, to load a CSV file with heart rate data we can do:\nfrom circadian.readers import load_csv\nfile_path = 'circadian/sample_data/hr_data.csv'\ndf_hr = load_csv(file_path, timestamp_col='timestamp')\n\n\n\n\n\n\n\n\n\nheartrate\ntimestamp\ndatetime\n\n\n\n\n0\n79.0\n4.688359e+07\n1971-06-27 15:13:12.693424232\n\n\n1\n80.0\n4.688329e+07\n1971-06-27 15:08:09.693448064\n\n\n2\n81.0\n4.688306e+07\n1971-06-27 15:04:20.692736632\n\n\n3\n80.0\n4.688273e+07\n1971-06-27 14:58:46.686474800\n\n\n4\n85.0\n4.688257e+07\n1971-06-27 14:56:08.187120912\n\n\n...\n...\n...\n...\n\n\n99995\n97.0\n3.271680e+07\n1971-01-14 15:59:56.779711960\n\n\n99996\n95.0\n3.271679e+07\n1971-01-14 15:59:49.779711960\n\n\n99997\n95.0\n3.271679e+07\n1971-01-14 15:59:48.779711960\n\n\n99998\n95.0\n3.271678e+07\n1971-01-14 15:59:43.779711960\n\n\n99999\n93.0\n3.271677e+07\n1971-01-14 15:59:34.779711960\n\n\n\n\n100000 rows × 3 columns\n\n\n\nby indicating which column contains the unix timestamp information, load_csv automatically generates a new column with the datetime information. If no timestamp column is provided, it is assumed that a column named ‘datetime’ (or ‘start’ and ‘end’) is present in the file. For data specified via time intervals, such as step counts, no new column is generated and the user can choose how to process the data. For example, to load a CSV file with step counts we can do:\nfile_path = 'circadian/sample_data/steps_data.csv'\ndf_steps = load_csv(file_path)\n\n\n\n\n\n\n\n\n\nstart\nend\nsteps\n\n\n\n\n0\n1970-01-01 00:00:00\n1970-01-01 00:01:00\n21.000000\n\n\n1\n1970-01-01 00:49:00\n1970-01-01 00:50:00\n8.183578\n\n\n2\n1970-01-01 00:50:00\n1970-01-01 00:51:00\n19.816422\n\n\n3\n1970-01-01 01:51:00\n1970-01-01 01:52:00\n0.571419\n\n\n4\n1970-01-01 01:52:00\n1970-01-01 01:53:00\n26.499032\n\n\n...\n...\n...\n...\n\n\n222765\n1971-06-27 14:24:00\n1971-06-27 14:25:00\n28.006870\n\n\n222766\n1971-06-27 14:25:00\n1971-06-27 14:26:00\n15.957981\n\n\n222767\n1971-06-27 14:26:00\n1971-06-27 14:27:00\n14.000000\n\n\n222768\n1971-06-27 14:37:00\n1971-06-27 14:38:00\n72.642453\n\n\n222769\n1971-06-27 14:38:00\n1971-06-27 14:39:00\n31.995192\n\n\n\n\n222770 rows × 3 columns\n\n\n\nAdditionally, we can import data in JSON format. For example, to load a JSON file with multiple streams of wereable data we can do:\nfile_path = 'circadian/sample_data/sample_data.json'\ndf_dict = load_json(file_path)\nprint(df_dict.keys())\n\n\ndict_keys(['wake', 'steps', 'heartrate'])\n\n\nwhere df_dict is a dictionary with the dataframes for each stream. The keys of the dictionary are the names of the streams. For example, to access the dataframe with the wake data we can do:\ndf_wake = df_dict['wake']\n\n\n\n\n\n\n\n\n\nstart\nend\nwake\n\n\n\n\n0\n1970-02-03 04:49:01.000000\n1970-02-03 09:01:00.000000\n0\n\n\n1\n1970-02-03 09:02:00.000000\n1970-02-03 11:25:00.000000\n0\n\n\n2\n1970-02-04 04:51:01.000000\n1970-02-04 12:35:00.000000\n0\n\n\n3\n1970-02-04 12:36:00.000000\n1970-02-04 12:37:00.000000\n0\n\n\n4\n1970-02-04 12:38:00.000000\n1970-02-04 12:39:00.000000\n0\n\n\n...\n...\n...\n...\n\n\n2750\n1971-06-27 07:38:31.105829\n1971-06-27 08:01:01.105829\n0\n\n\n2751\n1971-06-27 08:03:01.105829\n1971-06-27 08:55:31.105829\n0\n\n\n2752\n1971-06-27 09:05:31.105829\n1971-06-27 09:07:01.105829\n0\n\n\n2753\n1971-06-27 09:08:01.105829\n1971-06-27 12:06:01.105829\n0\n\n\n2754\n1971-06-27 12:08:01.105829\n1971-06-27 12:15:31.105829\n0\n\n\n\n\n2755 rows × 3 columns\n\n\n\nThe circadian.readers module only accepts specific column names for wereable data. The accepted column names are stored in VALID_WEREABLE_STREAMS:\n\n\n['steps', 'heartrate', 'wake', 'light_estimate', 'activity']\n\n\nFinally, we can import data from Actiwatch readers. For example, to load a CSV file with data from an Actiwatch reader we can do:\nfile_path = 'circadian/sample_data/sample_actiwatch.csv'\ndf_actiwatch = load_actiwatch(file_path)\n\n\n\n\n\n\n\n\n\nactivity\nlight_estimate\nwake\ndatetime\n\n\n\n\n0\n91.0\n318.16\n1.0\n2019-02-20 12:32:00\n\n\n1\n125.0\n285.38\n1.0\n2019-02-20 12:32:30\n\n\n2\n154.0\n312.05\n1.0\n2019-02-20 12:33:00\n\n\n3\n424.0\n294.61\n1.0\n2019-02-20 12:33:30\n\n\n4\n385.0\n285.06\n1.0\n2019-02-20 12:34:00\n\n\n...\n...\n...\n...\n...\n\n\n55646\n0.0\n5.02\n0.0\n2019-03-11 08:15:00\n\n\n55647\n56.0\n4.56\n1.0\n2019-03-11 08:15:30\n\n\n55648\n30.0\n2.85\n1.0\n2019-03-11 08:16:00\n\n\n55649\n9.0\n2.39\n0.0\n2019-03-11 08:16:30\n\n\n55650\n2.0\n2.20\nNaN\n2019-03-11 08:17:00\n\n\n\n\n55651 rows × 4 columns\n\n\n\nnote that load_actiwatch automatically generates a new column with the datetime information and standardizes column names.\n\n\nResampling wereable data\nThe circadian.readers module provides functionality to resample both data that is specified via time intervals or via timestamps. For example, to resample a dataframe with step counts we can do:\nname = 'steps'\nresample_freq = '1D'\nagg_method = 'sum'\nresampled_steps = resample_df(df_steps, name, resample_freq, agg_method)\n\n\n\n\n\n\n\n\n\ndatetime\nsteps\n\n\n\n\n0\n1970-01-01\n847.000000\n\n\n1\n1970-01-02\n1097.000000\n\n\n2\n1970-01-03\n1064.000000\n\n\n3\n1970-01-04\n2076.000000\n\n\n4\n1970-01-05\n2007.000000\n\n\n...\n...\n...\n\n\n538\n1971-06-23\n9372.098478\n\n\n539\n1971-06-24\n10142.402971\n\n\n540\n1971-06-25\n15012.305396\n\n\n541\n1971-06-26\n5747.457876\n\n\n542\n1971-06-27\n3823.642766\n\n\n\n\n543 rows × 2 columns\n\n\n\nwhere resample_freq is a string indicating the frequency of the resampling in Pandas offset aliases notation. Under name, the column to be resampled is specified and the agg_method parameter indicates how to aggregate the data.\n\n\nCombining wereable data\nWe can combine wereable data from different streams into a single dataframe. To achieve this we can use the combine_wereable_dataframes method which resamples and aggregates data to produce a dataframe with a single datetime index and columns for each stream. For example, to combine all the loaded dataframes from the previous section we would do:\ndf_dict = {\n    'heartrate': df_hr,\n    'steps': df_steps,\n    'wake': df_wake\n}\nresample_freq = '1D'\ncombined_data = combine_wereable_dataframes(df_dict, resample_freq)\n\n\n\n\n\n\n\n\n\ndatetime\nheartrate\nsteps\nwake\n\n\n\n\n0\n1970-01-04\n0.000000\n16188.000000\n0.0\n\n\n1\n1970-01-11\n0.000000\n19199.000000\n0.0\n\n\n2\n1970-01-18\n0.000000\n17888.000000\n0.0\n\n\n3\n1970-01-25\n0.000000\n31880.133432\n0.0\n\n\n4\n1970-02-01\n0.000000\n55150.172358\n0.0\n\n\n...\n...\n...\n...\n...\n\n\n73\n1971-05-30\n79.914844\n63341.399888\n0.0\n\n\n74\n1971-06-06\n97.080529\n96297.437512\n0.0\n\n\n75\n1971-06-13\n93.772603\n58357.605829\n0.0\n\n\n76\n1971-06-20\n99.018829\n75479.093737\n0.0\n\n\n77\n1971-06-27\n97.370401\n3823.642766\n0.0\n\n\n\n\n78 rows × 4 columns\n\n\n\nFor resampling, each wereable stream has a defaul aggregation method. The default methods are defined in the variable WEREABLE_RESAMPLE_METHOD:\n\n\n{'steps': 'sum', 'wake': 'max', 'heartrate': 'mean', 'light_estimate': 'mean', 'activity': 'mean'}"
  },
  {
    "objectID": "api/metrics.html",
    "href": "api/metrics.html",
    "title": "Metrics",
    "section": "",
    "text": "ESRI\nThe Entrainment Signal Regularity Index (ESRI) is a metric of circadian health introduced by Moreno et al. 2023 in the article Validation of the Entrainment Signal Regularity Index and associations with children’s changes in BMI. This metric quantifies how much light schedules entrain circadian rhythms. The ESRI metric uses a decoupled Hannay19 model: both the coupling between individual oscillators (parameter K) and frequency heterogeneity (parameter gamma) are set to 0. To calculate ESRI, fixed windows of a given light schedule are simulated, and the final amplitude of the decoupled model is taken as the ESRI value. This amplitude is close to 1 for highly entraining and regular schedules, and close to 0 for non-entraining schedules, like a train of random pulses. For more details see the original article.\nThe interface for calculating ESRI is given by esri. For example, we can compare the metric for four different light schedules:\n\nA regular schedule with 8 hours of darkness and 16 hours of light\nA shift work schedule with 5 days on and 2 days off\nA random schedule created with pulses of random start times and durations\nA constant darkness schedule\n\nimport matplotlib.pyplot as plt\nfrom circadian.metrics import esri\nfrom circadian.lights import LightSchedule\n\ndt = 0.1 # hours\ndays = 14\ntime = np.arange(0, 24*days, dt)\nesri_dt = 2.0 # hours\n# regular schedule\nregular_schedule = LightSchedule.Regular(lux=1000)\nregular_light = regular_schedule(time)\nesri_time_regular, esri_array_regular = esri(time, regular_light, esri_dt=esri_dt)\n# shift work schedule\nshift_schedule = LightSchedule.ShiftWork(lux=1000)\nshift_light = shift_schedule(time)\nesri_time_shift, esri_array_shift = esri(time, shift_light, esri_dt=esri_dt)\n# irregular schedule\nn_pulses = 8\nschedule = LightSchedule(0.0)\nfor n in range(n_pulses):\n    start = np.random.uniform(0, 24*days)\n    lux = np.random.uniform(10.0, 1000.0)\n    duration = np.random.uniform(5.0, 16.0)\n    schedule += LightSchedule.from_pulse(lux, start, duration)\nirregular_light = schedule(time)\nesri_time_irregular, esri_array_irregular = esri(time, irregular_light, esri_dt=esri_dt)\n# darkness schedule\ndarkness_schedule = LightSchedule(0.0)\ndarkness = darkness_schedule(time)\nesri_time_darkness, esri_array_darkness = esri(time, darkness, esri_dt=esri_dt)\n\n\n\n\n\nThis result shows the ESRI value for each start time of the analysis window. The default window length is 4 days, and the default window step is 1 hour. That’s why ESRI is only calculated for half of our simulation time (8 days). In the following plot, we see that the overall ESRI value for a highly regular schedule is larger than for a random schedule, and that the ESRI value for constant darkness is 0.1 which matches the default starting amplitude for the model. Both the window length and default starting amplitude can be changed with the analysis_days and initial_amplitude parameters."
  },
  {
    "objectID": "examples/skeldon23_sleep_model.html",
    "href": "examples/skeldon23_sleep_model.html",
    "title": "Combining sleep and circadian models",
    "section": "",
    "text": "Circadian rhythms govern our daily patterns of rest and wakefulness and determine when we fall asleep and wake up. However, models such as Forger99 or Hannay19 don’t predict sleep timing or duration. A family of models known as two-process models address this by coupling circadian rhythms with sleep pressure modeling. Here, we explore the two-process model in Skeldon et al. 2023 which combines Forger99’s circadian rhythm with a sleep homeostat that accumulates sleep pressure during wakefulness and dissipates during sleep. The model receives a light schedule as an input and is able to produce realistic sleep timings and durations. It is implemented in circadian.models as Skeldon23.\n\nRegular schedule\nIn order to obtain a prediction for sleep/wake onset, we need to provide the model with a light schedule. Following the original article, we’ll use a smooth light function defined in the following way:\n\ndef smooth_light(t):\n    rise = np.tanh(0.6 * (t - 8.0))\n    fall = np.tanh(0.6 * (t - 17.0))\n    y = (700.0 / 2.0) * (rise - fall) + 40.0\n    return y\n\nThen, we can define the schedule, equilibrate the model, and simulate:\n\nschedule = LightSchedule(smooth_light, period=24.0)\ndt = 0.01 # hours\ndays = 5\ntime = np.arange(8.0, 24 * days + 8.0, dt)\nlight = schedule(time)\nmodel = Skeldon23()\n# equilibrate model\ninitial_condition = model.equilibrate(time, light, num_loops=20)\n# simulate model\ntrajectory = model(time, initial_condition=initial_condition, input=light)\nsleep = model.sleep_state\nreceived_light = model.received_light\n\nNote that the model output constists of:\n\nA trajectory containing the information of the model’s four state variables (\\(x\\), \\(x_c\\), \\(n\\), and \\(H\\)) over time. Here we have favored Forger99’s notation of variables whereas the original article uses \\(x\\), \\(y\\), \\(n\\), and \\(H\\) respectively.\nA sleep array containing the sleep state for each timepoint. This is a binary array with 1 indicating sleep and 0 indicating wake.\nA received_light array encoding the light input to the circadian model for each timepoint. This light input is different from the provided light array only in those timepoints where the sleep state is 1 (i.e. asleep).\n\nWe can then visualize the predicted sleep windows\n\n\n\n\n\nand the circadian state from the \\(x\\) variable\n\n\n\n\n\nLight, being the primary input to the circadian model, drives the circadian state through the forcing term \\(B(t)\\):\n\n\n\n\n\nIn turn, the circadian state modulates sleep. Skeldon et al. define a function \\(C(t)\\) that determines the propensity of an individual to go to sleep or wake up.\n\n\n\n\n\n\\(C(t)\\) determines when the sleep pressure \\(H(t)\\) has accumulated sufficiently to trigger sleep (at threshold \\(H^+\\)) and when it has dissipated sufficiently to allow wake (at threshold \\(H^-\\)).\n\n\n\n\n\nTherefore, given any light schedule and initial conditions we can predict not only the phase of the circadian rhythm but also the timing and duration of sleep. In this simulation we obtain an average sleep timing and duration of\n\n# sleep start\nsleep_start_idxs = np.where(np.diff(sleep) == 1)[0]\nsleep_start_times = np.mod(time[sleep_start_idxs], 24.0)\navg_sleep_start = circmean(sleep_start_times, high=24.0)\n# sleep end\nsleep_end_idxs = np.where(np.diff(sleep) == -1)[0]\nsleep_end_times = np.mod(time[sleep_end_idxs], 24.0)\navg_sleep_end = circmean(sleep_end_times, high=24.0)\n# sleep duration\nsleep_end_idxs = np.where(np.diff(sleep) == -1)[0]\nsleep_duration = time[sleep_end_idxs] - time[sleep_start_idxs]\n\nAverage sleep start: 23.79 h, Average sleep end: 7.09 h, Average sleep duration: 7.30 h\n\n\n\n\nShift work schedule\nThe model allows us to explore how much sleep would a shift worker get in a typical light schedule. Applying the same pipeline as above but using LightSchedule.ShiftWork we obtain the following results:\nschedule = LightSchedule.ShiftWork()\ndt = 0.01 # hours\ndays = 7\ntime = np.arange(0, 24 * days, dt)\nlight = schedule(time)\nmodel = Skeldon23()\n# equilibrate model\ninitial_condition = model.equilibrate(time, light)\n# simulate model\ntrajectory = model(time, initial_condition=initial_condition, input=light)\nsleep = model.sleep_state\nreceived_light = model.received_light\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# sleep start\nsleep_start_idxs = np.where(np.diff(sleep) == 1)[0]\nsleep_start_times = np.mod(time[sleep_start_idxs], 24.0)\navg_sleep_start = circmean(sleep_start_times, high=24.0)\n# sleep end\nsleep_end_idxs = np.where(np.diff(sleep) == -1)[0]\nsleep_end_times = np.mod(time[sleep_end_idxs], 24.0)\navg_sleep_end = circmean(sleep_end_times, high=24.0)\n# sleep duration\nsleep_end_idxs = np.where(np.diff(sleep) == -1)[0]\nsleep_duration = time[sleep_end_idxs] - time[sleep_start_idxs]\n\nAverage sleep start: 13.41 h, Average sleep end: 20.73 h, Average sleep duration: 7.32 h\n\n\nEven though the sleep duration is not so different from the regular schedule, the sleep timing clashes with the shift in light exposure during days off (days 5 and 6). The model keeps the rhythm of previous shift work days, making it hard to switch to a regular schedule on days off.\n\n\nPredicted sleep as a function of circadian period \\(\\tau_c\\)\nIn the original article, Skeldon et al. explore how different parameters affect sleep duration, mid-sleep timing, and circadian state minimum. Using circadian we can do a similar exploration, analyzing how the intrinsic period \\(\\tau_c\\) modulates these quantities under two different light schedules, one with low baseline intensity (10 lux) and one with high baseline intensity (100 lux).\n\ndef low_baseline_schedule(t):\n    rise = np.tanh(t - 7.0)\n    fall = np.tanh(t - 18.0)\n    y = ((10000.0 - 10.0) / 2.0) * (rise - fall) + 10.0\n    return y\n\ndef high_baseline_schedule(t):\n    rise = np.tanh(t - 7.0)\n    fall = np.tanh(t - 18.0)\n    y = ((10000.0 - 100.0) / 2.0) * (rise - fall) + 100.0\n    return y\n\nlight_schedules = {\n    'low_baseline': LightSchedule(low_baseline_schedule, period=24),\n    'high_baseline': LightSchedule(high_baseline_schedule, period=24)\n}\n\n\n\n\n\n\nFor each value of intrinsic period we equilibrate the system for 60 days and then store 5 days of simulated data:\n\nresults = {\n    'low_baseline': {\n        'trajectories': [],\n        'sleep': [],\n        'sleep_duration': [],\n        'mid_sleep_time': [],\n        'circadian_minimum_time': []\n    },\n    'high_baseline': {\n        'trajectories': [],\n        'sleep': [],\n        'sleep_duration': [],\n        'mid_sleep_time': [],\n        'circadian_minimum_time': []\n    }\n}\n\ndt = 0.05 # hours\ndays = 5\ntime = np.arange(0, 24 * days, dt)\nintrinsic_periods = np.linspace(23.6, 24.25, 20)\n\nfor schedule_name in light_schedules:\n    schedule = light_schedules[schedule_name]\n    light = schedule(time)\n    for tauc in intrinsic_periods:\n        model = Skeldon23(params={'tauc': tauc})\n        # equilibrate model\n        initial_condition = model.equilibrate(time, light, num_loops=12)\n        # simulate model\n        trajectory = model(time, initial_condition, light)\n        # calculate sleep metrics\n        sleep = model.sleep_state\n        mid_sleep_time, sleep_duration = sleep_midpoint_and_duration(time, sleep)\n        circadian_minimum = np.mean(np.mod(model.cbt(), 24))\n        # store results\n        results[schedule_name]['trajectories'].append(trajectory)\n        results[schedule_name]['sleep'].append(sleep)\n        results[schedule_name]['sleep_duration'].append(sleep_duration)\n        results[schedule_name]['mid_sleep_time'].append(mid_sleep_time)\n        results[schedule_name]['circadian_minimum_time'].append(circadian_minimum)\n\nWe can visualize the effect of the intrinsic period on the predicted sleep windows\n\n\n\n\n\n\n\n\nas well as its effect on the circadian rhythm:\n\n\n\n\n\n\n\n\nThe high baseline simulations seem to affect both sleep and circadian state the most.\nThe high baseline schedule seems to have a greater effect on sleep and circadian state than the low baseline schedule. On our main simulation loop, we used the function sleep_midpoint_and_duration from the module circadian.utils to quantify these effects. Their plots are shown below and confirm this observation in agreement with the results from Skeldon et al. 2023:"
  }
]